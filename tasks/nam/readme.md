# Нормальные алгоритмы Маркова

Из видов алгоритмических моделей принято выделять три:
- Машина Тьюринга.
- [Лямбда-исчисление](https://neerc.ifmo.ru/wiki/index.php?title=Лямбда-исчисление), не изучаемое в этом курсе.
- Нормальные алгоритмы Маркова. 

В этом задании попробуем программировать именно в последней. Для выполнения задания требуется установить [эмулятор](https://drive.google.com/file/d/1EylGwV1FFed-limXIOagP0B5XYOFIJR-/view?usp=drive_link), работающий прямо в браузере, на JavaScript.

## Формальное описание
Для описания модели Маркова требуются три компонента:
- Алфавит.
- Правила подстановки.
- Начальное состояние.

### `Алфавит`
Это любые символы, как правило из ACSII таблицы.

### `Правила подстановки`
Это набор правил замены одного символа на другой.
Шаблон выглядит так:   
```src->dst```. </br>
Читать следует так: заменить строку ```src``` на строку ```dst```.

### `Начальное состояние`
Начальным состоянием является входная строка.

## Общие сведения
Как правило, для перемещения по строке используют символ ```*```. Ниже будет пример, где станет понятнее о чём речь.

Чтобы звершить выполнение программы, следует ввести правило:   
```src->.```  

Также выполнение автоматически заканчивается, когда невозможно применить ни одно из правил.

Инструкции выполняются сверху вниз.

## Пример
Решим простую задачу кодирования по Цезарю входной строки с фиксированным ключом 3. Алфавитом возьмём римские цифры: {I, V, X, L, C, D, M}   
Программа будет выглядеть вот так:
```
*I->L*
*V->C*
*X->D*
*L->M*
*C->I*
*D->V*
*M->X*
*->.
->*
```

Для примера возьмём простую строку: DCL    
И выполним пошагово:

1) Выполнится правило ```->*```(пустоту заменить на *), так как все правила выше не сработают. Наша строка теперь стала такой: *DCL
2) Выполнится правило ```*D->V*```. Наша строка теперь стала такой: V*CL
3) Выполнится правило ```*C->I*```. Наша строка теперь стала такой: VI*L
4) Выполнится правило ```*L->M*```. Наша строка теперь стала такой: VIM*
5) Выполнится правило ```*->.```. Программа окончена, ответ - VIM.

В случае Маркова, о нормированности обычно речь не идёт, копировать исходные данные не требуется.

> Подумайте, как решить эту задачу с переменным ключом. Например, входные данные выглядят так: ```LDM&|||```, где & - разделитель, а символами | мы задали ключ в унарной системе счисления.

## Задание

Вам необходимо решить задачу вашего варианта. Свой вариант можно найти [тут](variants.md).

Дополнительные условия и требования аналогичны [заданию про МТ](../turing_machine/), за исключением условия нормированности.





