Задание:
        Проверка последовательности на монотонное убывание

Идея:
        Будем сравнивать каждый элемент с идущим за ним, дублируя второй.        
        Если элемент окажется последним, то последовательность монотонно убывает и выводим 1. 
        Если же в какой-то паре окажудтся два одинаковых элемента или второй будет больше первого, то все числа затираются
        и выводится 0.

        Сравнение происходит благодаря вычитанию единица из каждого элемента, пока один не становится равен нулю

Программа:

// Элементы разделены пробелом, который обозначается, как λ 


// Зачистка данных и завершение программы с положительным результатом
\λ\λ ->  a
 1a  ->  a
 0a  ->  a 
  a  ->  1.

// Зачистка данных и завершение программы с отрицптельным результатом
 ss  ->  !
 !0  ->  !
 !1  ->  !
 !λ0 ->  !
 !λ1 ->  !
 !|  ->  ! 
 !/  ->  !
 !?  ->  !
  !  ->  0.

// Удаление первого элемента
 1{  ->  {
 0{  ->  {
 s{  ->  { 
 \]  ->  ]
 0]  ->  ]
 1]  ->  ]

// Числа равны
 |]  ->  {

// Создание указателы ! для удаления всего
  {  ->  !

// Первый элемент больше второго
  ]  ->  λ

// Проход по первому элементу и начало создания указателей
 *1  -> 1*
 *0  -> 0*
 *λ  -> \λ\

// Копирование второго элемента в виде oz, где o - это единицы, а z - нули
 \0  -> 0z\ 
 \1  -> 1o\
 z0  -> 0z 
 z1  -> 1z
 o0  -> 0o
 o1  -> 1o

// Перевод копии из вида oz в нормальное число
 o\  -> /1
 z\  -> /0
 o/  -> /1
 z/  -> /0

// Разделение второго элемента и его копии
 0/1 -> 0/λ1
 1/1 -> 1/λ1

// Востановление указателей для уменьшения чисел
 |λ? -> \λr

// Уменьшение последнего ненулевого разряда с присвоением последующим разрядам 1
 0<  -> <0
 1<  -> 0>
 >0  -> 1>
  >  -> λ

// Создание "флага" обозначающего равенство нулю элемента
  <  ->  s

// Удаление второго элемента и подготовка удаления первого, с проверкой того на 0
 s?0 -> s?
 λs? ->  ]

// Проход к концу первого элемента и началу второго для одновременного создания указателей
 0?  -> ?0
 1?  -> ?1

// Постановка указателя "/" в крайную правую позицию второго элемента
 r0  -> 0r
 r1  -> 1r 
 r  ->  /

// Декремент
 0\  -> <0|
 0/  -> <0?
 1\  -> 0|
 1/  -> 0?

// Создание * как первого указателя для прохода по числам
  λ  ->  *

Сложность:

        Сложность по времени - O(n*m), где n - это максимальное значение второго элемента в монотонной последовательности,
        а m - это количество элементов последовательности.