# Целые числа и системы счисления

В этой задаче научимся использовать целые числа правильно.

## Знаковый и беззнаковый тип
По стандарту современных процессоров, числа представлены в дополнительном коде.
Крайний слева бит отвечает за знак: 0, если число положительное и 1 если отрицательное.

Так выглядит классический `int`. Диапазон возможных значений в таком случае: $$[-2^{31},2^{31} - 1]$$
> Размер int зависит от архитектуры процессора, о чём написано ниже. По умолчанию информация соответсвует процессорам на архитектуре Intel x86-64.

Имеется также `unsigned int`, в котором знаковый бит трактуется как обычный. Диапазон значений в таком случае выглядит так: $$[0,2^{32} - 1]$$ Это неплохой способ сказать программисту, что значение переменной не будет отрицательным.   

*Не стоит экономить на спичках и везде писать unsigned, чтобы получить бОльший диапазон значений. Это может мешать оптимизациям компилятора, из-за чего код будет работать медленее.*

## Переполнения
Что будет, если выполнить этот код?
```c
int32_t a = INT_MAX;
printf("%d", a + 1);
```

Согласно стандарту языка, такие ситуации называются [Undefined behavior - UB](https://en.wikipedia.org/wiki/Undefined_behavior).   

Это означает, что поведение неопределенно и пользователь не должен расчитывать на какой-либо однозначный результат. Это в теории. На практике компиляторы могут выдавать осознанный результат. Однако нужно избегать подобных ситуаций в коде, потому что отлавливать подобное поведение очень трудно, а оно почти всего приводит к ошибкам:
```c
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>

bool Overflow(int a) {
    return (a + 1) > a;
}

int main() {
    printf("overflow: %d\n", Overflow(INT_MAX));
    printf("INT_MAX + 1 > INT_MAX: %d\n", (INT_MAX + 1) > INT_MAX);
}
```
Очевидно, что мы ожидаем одинаковый результат. Однако, скопилировав через gcc, получим:
```shell
gcc test.c -o test
./test
overflow: 1
INT_MAX + 1 > INT_MAX: 0
```
А теперь скомпилируем тот же код при помощи компилятора clang:
```shell
clang test.c -o test
./test
overflow: 0
INT_MAX + 1 > INT_MAX: 0
```
Здорово, наш код зависит от компилятора!

- Если интересно, зачем UB существует в С/C++, посмотрите [доклад](https://www.youtube.com/watch?v=B9iR13VyP-c&t=13133s) на эту тему.

## Считаем байтики
### `Зависимость от архитектуры процессора`
Стандарт C++ оставляет определение размеров типов данных нестрого определенным, и размер int может отличаться на различных платформах.

Из популярных архитектур процессоров выделяют следующие:
- Intel x86
- Intel x86-64
- ARM 
- PowerPC

В Intel x86 размер регистра 32 бита = 4 байта.  
В Intel x86-64 размер регистра 64 бита = 8 байт.

`В Intel x86`:
- int - 32 бит
- long int - 64 бита

Для того, чтобы обозначить long int в x86, компилятор [использует структуру](https://en.wikipedia.org/wiki/Endianness):
```c
struct long {
    int32_t high,
    uint32_t low
}
```

`В Intel x86-64`:
- int - 32 бит
- long int - 64 бита

## Явно всегда лучше, чем неявно

Чтобы код выполнялся одинаково на всех архитектурах, существуют [специальные типы](https://en.cppreference.com/w/c/types/integer), чётко определяющие размер переменных:
```c
#include <stdint.h>
int64_t a;
int32_t b;
uint64_t c;
```
Именно ими мы и будем оперировать дальше, отказываясь от стандартных **int**, **long long int**, **unsigned int**.

- Существует также специальный тип [`size_t`](http://en.wikipedia.org/wiki/Size_t), которым обозначают размеры. Представляет из себя беззнаковое целое число с максимальным для данной машины размером.

## Позиционные системы счисления

- Для [тех](https://ru.wikipedia.org/wiki/Позиционная_система_счисления), кто в танке.

Нам интересны всего две: бинарная и шестнадцатиричная.

[Бинарная СС](https://ru.wikipedia.org/wiki/Двоичная_система_счисления) оказалось очень удачной в тандеме с транзистором: 0 - тока нет, 1 - ток есть. И булева алгебра, применяемой на схемах.

Поэтому компьютеры и работают с бинарными числами. Существовали эксперименты с компьютерами на троичной системе счисления, но они не прижились.

Однако хранить числа в бинарной СС невыгодно - слова слишком длинные. Числа в памяти лежат в 16-ой = 
[Hexadecimal(Hex)](https://www.techtarget.com/whatis/definition/hexadecimal). Любое целое число можно распечатать или задать, используя hex:
```c
int32_t k = 0xFF // 0x - означает, что это Hex число. В 10-ой это 255.
printf("%d\n", k) // Напечатает 255
printf("%x\n", k) // Напечатает ff
```

## Задание

Вам необходимо решить задачу вашего варианта. Свой вариант можно найти [тут](variants.md).

## Важные требования к решению
Чтобы получить максимальный балл за задачу, необходимо удовлетворять следующим критериям:
- Запрещается работать с числом как со строкой.
- Запрещается использовать массивы.
- Нет ограничений на входные данные.
- Код должен быть понятным, названия переменных отражают то, что они хранят.

